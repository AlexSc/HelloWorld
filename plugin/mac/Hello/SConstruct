# Requirements
########################################################################
import re

from SCons.Script import *
from SCons.Defaults import SharedCheck, ProgScan
from SCons.Script.SConscript import SConsEnvironment
import SCons.Errors


# This will replace any occurance of @keyname@ with the value of the
# key from the environment dictionary.  @@ will produce a single @
########################################################################

_searchre = re.compile('@(.*?)@')

def subst_file(target, source, data):
    # Sub function
    def subfn(mo, data=data):
        key = mo.group(1)
        if key == '':
            return '@'
        return data[key]

    # Read file
    f = open(source, 'rU')
    try:
        contents = f.read()
    finally:
        f.close()

    # Substitute
    contents = _searchre.sub(subfn, contents)

    # Write file
    f = open(target, 'wt')
    try:
        f.write(contents)
    finally:
        f.close()

def subst_keys(source):
    keys = []

    # Sub function
    def subfn(mo):
        key = mo.group(1)
        if key != '':
            keys.append(key)
        return ''

    # Read file
    f = open(source, 'rU')
    try:
        contents = f.read()
    finally:
        f.close()

    # Determine keys
    _searchre.sub(subfn, contents)

    return keys

def subst_in_file(target, source, env):
    # What keys do the sources use
    keys = []

    for s in source:
        skeys = subst_keys(str(s))
        for k in skeys:
            if not k in keys:
                keys.append(k)

    # Get these keys from the environment
    d = dict()
    for k in keys:
        try:
            v = env[k]
        except:
            raise SCons.Errors.UserError('SubstInFile key not found in environment: ' + k)

        if callable(v):
            d[k] = env.subst(v())
        elif SCons.Util.is_String(v):
            d[k] = env.subst(v)
        else:
            raise SCons.Errors.UserError('SubstInFile key must be a string or callable: ' + k)

    # Substitute in the files
    for (t, s) in zip(target, source):
        subst_file(str(t), str(s), d)

    return 0


def subst_string(target, source, env):
    items = ['Substituting vars from %s to %s' % (str(s), str(t))
             for (t, s) in zip(target, source)]

    return '\n'.join(items)

def subst_emitter(target, source, env):
    for (t, s) in zip(target, source):
        # Get keys used
        keys = subst_keys(str(s))

        d = dict()
        for k in keys:
            try:
                v = env[k]
            except:
                raise SCons.Errors.UserError('SubstInFile key not found in environment: ' + k)

            if callable(v):
                d[k] = env.subst(v())
            elif SCons.Util.is_String(v):
                d[k] = env.subst(v)

        # Only the current target depends on this dictionary
        Depends(t, SCons.Node.Python.Value(d))

    return target, source

# Create builders
def TOOL_SUBST(env):
    subst_in_file_action = SCons.Action.Action(subst_in_file, subst_string)
    env['BUILDERS']['SubstInFile'] = Builder(action=subst_in_file_action,
                                             emitter=subst_emitter)

def TOOL_BUNDLE(env):
    """defines env.LinkBundle() for linking bundles on Darwin/OSX, and
       env.MakeBundle() for installing a bundle into its dir.
       A bundle has this structure: (filenames are case SENSITIVE)
       sapphire.bundle/
         Contents/
           Info.plist (an XML key->value database; defined by BUNDLE_INFO_PLIST)
           PkgInfo (trivially short; defined by value of BUNDLE_PKGINFO)
           MacOS/
             executable (the executable or shared lib, linked with Bundle())
    Resources/
         """
    if 'BUNDLE' in env['TOOLS']: return
    if env['PLATFORM'] == 'darwin':
        env.Append(TOOLS = 'BUNDLE')
        # This is like the regular linker, but uses different vars.
        # XXX: NOTE: this may be out of date now, scons 0.96.91 has some bundle linker stuff built in.
        # Check the docs before using this.
        LinkBundle = SCons.Builder.Builder(action=[SharedCheck, "$BUNDLECOM"],
                                           emitter="$SHLIBEMITTER",
                                           prefix = '$BUNDLEPREFIX',
                                           suffix = '$BUNDLESUFFIX',
                                           target_scanner = ProgScan,
                                           src_suffix = '$BUNDLESUFFIX',
                                           src_builder = 'SharedObject')
        env['BUILDERS']['LinkBundle'] = LinkBundle
        env['BUNDLEEMITTER'] = None
        env['BUNDLEPREFIX'] = ''
        env['BUNDLESUFFIX'] = ''
        env['BUNDLEDIRSUFFIX'] = '.bundle'
        env['BUNDLE'] = '$SHLINK'
        env['BUNDLEFLAGS'] = ' -bundle'
        env['BUNDLECOM'] = '$BUNDLE $BUNDLEFLAGS -o ${TARGET} $SOURCES $_LIBDIRFLAGS $_LIBFLAGS $FRAMEWORKS'
        # This requires some other tools:
        TOOL_WRITE_VAL(env)
        TOOL_SUBST(env)
        # Common type codes are BNDL for generic bundle and APPL for application.
        def MakeBundle(env, bundledir, app,
                       info_plist,
                       typecode='BNDL', creator='????',
                       subst_dict=None,
                       resources=[]):
            """Install a bundle into its dir, in the proper format"""
            # Substitute construction vars:
            for a in [bundledir, info_plist, typecode, creator]:
                a = env.subst(a)
            if SCons.Util.is_List(app):
                app = app[0]
            if SCons.Util.is_String(app):
                app = env.subst(app)
                appbase = app
            else:
                appbase = str(app)
            if not ('.' in bundledir):
                bundledir += '.$BUNDLEDIRSUFFIX'
            bundledir = env.subst(bundledir) # substitute again
            suffix=bundledir[string.rfind(bundledir,'.'):]
            if (suffix=='.app' and typecode != 'APPL' or
                suffix!='.app' and typecode == 'APPL'):
                raise Error, "MakeBundle: inconsistent dir suffix %s and type code %s: app bundles should end with .app and type code APPL."%(suffix, typecode)
            if subst_dict is None:
                subst_dict={'%SHORTVERSION%': '$VERSION_NUM',
                            '%LONGVERSION%': '$VERSION_NAME',
                            '%YEAR%': '$COMPILE_YEAR',
                            '%EXECUTABLE_NAME%': appbase,
                            '%CREATOR%': creator,
                            '%TYPE%': typecode}
            env.Install(bundledir+'/Contents/MacOS', app)
            f=env.SubstInFile(bundledir+'/Contents/Info.plist', info_plist,
                            SUBST_DICT=subst_dict)
            env.Depends(f,SCons.Node.Python.Value(creator+typecode+env['VERSION_NUM']+env['VERSION_NAME']))
            env.WriteVal(target=bundledir+'/Contents/PkgInfo',
                         source=SCons.Node.Python.Value(typecode+creator))
            for r in resources:
                if SCons.Util.is_List(r):
                    env.InstallAs(join(bundledir+'/Contents/Resources',
                                               r[1]),
                                  r[0])
                else:
                    env.Install(bundledir+'/Contents/Resources', r)
            return [ SCons.Node.FS.default_fs.Dir(bundledir) ]
        # This is not a regular Builder; it's a wrapper function.
        # So just make it available as a method of Environment.
        SConsEnvironment.MakeBundle = MakeBundle

def TOOL_WRITE_VAL(env):
    env.Append(TOOLS = 'WRITE_VAL')
    def write_val(target, source, env):
        """Write the contents of the first source into the target.
        source is usually a Value() node, but could be a file."""
        f = open(str(target[0]), 'wb')
        f.write(source[0].get_contents())
        f.close()
    env['BUILDERS']['WriteVal'] = Builder(action=write_val)

SConscript(['../../../scons/Universal'])

env = Environment(CPPPATH=['../../inc', '../../../lib'], LIBPATH='../../../lib', FRAMEWORKS=[])
TOOL_BUNDLE(env)
env.DoUniversal('LoadableModule', 'Hello', 'plugin.cpp', LIBS='hello')
env['VERSION_NUM'] = '1.0'
env['VERSION_NAME'] = '1.0'

env.MakeBundle('Hello.plugin', 'Hello',
              'Info.plist',
              typecode='BRPL', creator='????')

